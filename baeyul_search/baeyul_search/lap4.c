////배열을 활용한 정렬과 탐색 실습
////삽입 정렬(INSERT SORT) 이 알고리즘은 점진적으로 정렬범위를 넓혀나가는 방식으로 정렬하는 알고리즘이다
////새로운 범위에 포함되는 마지막 원을 앞으로 비교하면서 이동하면서 자신보다 작은 요소를 찾을 때까지 이동하면서
////자리를 교환해 나가는 알고리즘 이다. 이미 정렬된 배열부분과 비교하여 자신의 값과 이전의 값을 비교하면서 
////작은 값을 만나면 뒤에있는 요소와 앞에있는 요소 중간에 삽입을 해주는 방식이다.
////장점은 정렬속도가 상당히 빠르다. 단점은 역순(배열요소가 내림차순)으로 되어 비교를 상대적으로 많이 하기 때문에 느려진다.
//
////삽입정렬의 실습
//#include <stdio.h>
//#define LENGTH 10
////매크로 함수는 아래와 같이 선언 및 구현을 하는데 매크로다 보니 한줄로 작성하도록 한다. 
////간단한코드만 매크로 함수로 구현해서 사용하면 편리하다
//#define SWAP(x,y) {int temp=0;temp=x;x=y;y=temp;}
//void insert_sort(int arr[], int size);
//void printArr(int arr[], int size);
//int main(void)
//{
//	int arr[LENGTH] = { 1,8,-2,0,11,5,7,10,8,6 };		//배열요소 10개로 초기화
//	insert_sort(arr, LENGTH); //삽입정렬 함수 호출 
//	return 0;
//}
////사용자 정의 함수 구현
//void insert_sort(int arr[], int size)
//{
//	int i = 0, j = 0, cnt = 0;
//	printf("===============================\n");
//	printf("현재 정렬 전 배열 요소들의 값\n");
//	printf("===============================\n");
//	printArr(arr,size);
//	//삽입 정렬코드
//	//i값을 1로 설정한 이유는 첫 번재 루핑을 할 때, 0인덱스와 비교를 해야 하기 때문이다.
//	for (i = 1; i < size; i++)		//외곽 루프에서 정렬할 범위를 확대해가는 기능을 하고있다
//	{
//		for(j=i;j>0;j--)
//		{ 
//			if(arr[j-1]>arr[j])		//앞에있는 요소가 더크다면
//				{
//				SWAP(arr[j - 1], arr[j]);
//				printArr(arr, size); //앞의 요소가 더 크면 자리가 바뀌는 것을 출력을  로그형식으로
//				cnt++;
//				}
//			else {//앞의 요소가 작다면...내부 루프를 탈출하고 외부루프의 증감식으로 이동함
//				break;
//			}
//		}
//	}
//	printf("\n비교횟수 :%d\n", cnt);
//	return ;
//}
//void printArr(int arr[], int size)
//{
//	int i = 0;
//	for (i = 0; i < size; i++)
//	{
//		printf(" %2d", arr[i]);
//	}
//	printf("\n");
//
//
//	return ;
//}
